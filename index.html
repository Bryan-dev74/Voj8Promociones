<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Juego de Promociones VOJ8</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    :root { --bg-dark:#1a1a1a; --bg-card:#2c2c2c; --gold:#f8b600; --gold-dark:#d89e00; --text-light:#f5f5f5; --success:#22c55e; --error:#ef4444; }
    body{font-family:'Inter',sans-serif;background:var(--bg-dark);color:var(--text-light)}
    .card{background:var(--bg-card);border-radius:1rem;border:1px solid rgba(255,255,255,.1);transition:.3s}
    .btn{transition:.3s;border-radius:.5rem;font-weight:600;text-transform:uppercase;letter-spacing:.05em}
    .btn-gold{background:var(--gold);color:var(--bg-dark)}
    .btn-gold:hover{background:var(--gold-dark);transform:translateY(-2px);box-shadow:0 4px 15px rgba(248,182,0,.2)}
    .option-btn{background:#3f3f46;border:2px solid transparent}
    .option-btn:not([disabled]):hover{border-color:var(--gold);color:var(--gold)}
    .option-btn.correct{background:var(--success);color:#fff;border-color:var(--success)}
    .option-btn.incorrect{background:var(--error);color:#fff;border-color:var(--error)}
    .option-btn:disabled{cursor:not-allowed}
    .flashcard-container{perspective:1000px}
    .flashcard{transform-style:preserve-3d;transition:transform .6s}
    .flashcard.is-flipped{transform:rotateY(180deg)}
    .flashcard-face{backface-visibility:hidden;-webkit-backface-visibility:hidden}
    .flashcard-back{transform:rotateY(180deg)}
    @keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
    .fade-in{animation:fadeIn .4s ease-out forwards}
    .toggle{display:inline-flex;align-items:center;gap:.5rem}
    .toggle input{width:44px;height:24px;appearance:none;background:#3f3f46;border-radius:999px;position:relative;outline:none;cursor:pointer}
    .toggle input:checked{background:var(--gold)}
    .toggle input::after{content:"";position:absolute;width:18px;height:18px;top:3px;left:3px;background:#fff;border-radius:999px;transition:.2s}
    .toggle input:checked::after{left:23px}
    .timer{font-variant-numeric:tabular-nums}
    .btn:disabled { opacity:.5; cursor:not-allowed; filter:grayscale(.7); transform:none; box-shadow:none; }
    .btn-gold:disabled { background:#9ca3af; color:#1a1a1a; }
  </style>
</head>
<body class="min-h-screen">
  <div class="container mx-auto p-4 md:p-8 max-w-7xl">
    <header class="text-center mb-6 fade-in">
      <img src="logo.png" alt="VOJ8 Logo" class="mx-auto h-16 mb-4">
      <h1 class="text-4xl md:text-5xl font-black">Centro de Entrenamiento de Promociones</h1>
      <p class="text-lg text-gray-400 mt-2">¡Domina cada bono y maximiza tus ganancias!</p>
    </header>
    <main id="main-content"></main>
  </div>

  <script>
    const SHOW_EXPLANATION = true;

    /* =================== DATA =================== */
    const promotionsData = {
      "Bônus de 1º Depósito + Roda da Fortuna": {
        questions: [
          { question: "¿Qué porcentaje de bono se ofrece en el primer depósito?", answer: "100%" },
          { question: "¿Cuál es el depósito mínimo para participar?", answer: "R$20" },
          { question: "¿Cuál es el bono máximo que se puede recibir?", answer: "R$1.000" },
          { question: "¿Qué premio adicional se recibe?", answer: "Giro en la Roda da Fortuna" },
          { question: "¿Cuál es el rollover para este bono?", answer: "15x" }
        ],
        fillInTheBlanks: [
          { text: "El bono de primer depósito es de __% hasta R$1.000.", answer: "100" },
          { text: "El rollover para este bono es de __x.", answer: "15" }
        ],
        flashcards: [
          { front: "Porcentaje del bono", back: "100%" },
          { front: "Bono máximo", back: "R$1.000" },
          { front: "Premio adicional", back: "Giro en la Roda da Fortuna" },
          { front: "Rollover", back: "15x" }
        ]
      },
      "Bônus de Segundo Depósito": {
        questions: [
          { question: "¿Cuál es el depósito mínimo para participar?", answer: "R$50" },
          { question: "¿Cuál es el bono máximo que se puede recibir?", answer: "R$5.555" },
          { question: "¿Cuál es el rollover para este bono?", answer: "5x" },
          { question: "¿Cómo se activa este bono?", answer: "Manual al depositar" }
        ],
        fillInTheBlanks: [
          { text: "El bono de segundo depósito puede llegar hasta R$__.", answer: "5555" },
          { text: "El rollover para este bono es de __x.", answer: "5" }
        ],
        flashcards: [
          { front: "Depósito mínimo", back: "R$50" },
          { front: "Bono máximo", back: "R$5.555" },
          { front: "Rollover", back: "5x" }
        ]
      },
      "Bônus Diário de 10%": {
        questions: [
          { question: "¿Qué porcentaje de bono diario se ofrece?", answer: "10%" },
          { question: "¿Cuál es el valor mínimo por recarga para participar?", answer: "R$10" },
          { question: "¿Cuál es el bono máximo por día?", answer: "R$77" },
          { question: "¿Cuál es el rollover para este bono?", answer: "1x" },
          { question: "¿Qué requisito principal debes cumplir para participar?", answer: "Ser miembro del grupo oficial de Telegram" }
        ],
        fillInTheBlanks: [
          { text: "El bono diario te bonifica un __% para que puedas lucrar todo el día.", answer: "10" },
          { text: "El rollover para este bono es de __x.", answer: "1" }
        ],
        flashcards: [
          { front: "Porcentaje del bono diario", back: "10%" },
          { front: "Rollover", back: "1x" },
          { front: "Bono máximo por día", back: "R$77" }
        ]
      },
      "Mega Check-in 10 Dias": {
        questions: [
          { question: "¿Cuántos días dura el evento de Mega Check-in?", answer: "10" },
          { question: "¿Cuál es el depósito mínimo diario para participar?", answer: "R$20" },
          { question: "¿Cuál es el rollover para este bono?", answer: "3x" },
          { question: "¿Qué sucede si se omite un día de check-in?", answer: "El evento se reinicia y se pierden todos los bonos" }
        ],
        fillInTheBlanks: [
          { text: "El evento dura __ días.", answer: "10" },
          { text: "El rollover para este bono es de __x.", answer: "3" }
        ],
        flashcards: [
          { front: "Depósito mínimo diario", back: "R$20" },
          { front: "Rollover", back: "3x" },
          { front: "Consecuencia de faltar un día", back: "Pierdes todos los bonos" }
        ]
      },
      "Cashback Instantâneo": {
        questions: [
          { question: "¿Qué tipo de apuestas califican para el cashback instantáneo?", answer: "Cualquier juego de casino" },
          { question: "¿Cuál es el porcentaje máximo de cashback en slots?", answer: "2%" },
          { question: "¿A qué hora se paga el cashback?", answer: "A las 16:00 del día siguiente" }
        ],
        fillInTheBlanks: [
          { text: "El cashback máximo en slots es de __%.", answer: "2" }
        ],
        flashcards: [
          { front: "Tipo de apuestas válidas", back: "Cualquier juego de casino" },
          { front: "Cashback máximo en slots", back: "2%" },
          { front: "Hora de pago", back: "16:00 del día siguiente" }
        ]
      },
      "Cashback Secreto": {
        questions: [
          { question: "¿En qué juegos aplica el cashback secreto?", answer: "Slots" },
          { question: "¿Cuál es el porcentaje de cashback por pérdidas?", answer: "3%" },
          { question: "¿Cuál es la pérdida mínima para calificar?", answer: "R$40" },
          { question: "¿Cuál es el rollover para este bono?", answer: "1x" }
        ],
        fillInTheBlanks: [
          { text: "El cashback secreto es de __% en slots.", answer: "3" },
          { text: "La pérdida mínima para calificar es de R$__.", answer: "40" }
        ],
        flashcards: [
          { front: "Juegos válidos", back: "Slots" },
          { front: "Porcentaje de cashback", back: "3%" },
          { front: "Rollover", back: "1x" }
        ]
      },
      "Cashback USDT": {
        questions: [
          { question: "¿Qué porcentaje de cashback se gana en cada depósito con USDT?", answer: "0.3%" },
          { question: "¿Hay límite de cashback por depósito con USDT?", answer: "No hay límite" }
        ],
        fillInTheBlanks: [
          { text: "El cashback por depósito con USDT es de __%.", answer: "0.3" }
        ],
        flashcards: [
          { front: "Porcentaje de cashback", back: "0,3%" },
          { front: "Límite de cashback", back: "No hay límite" }
        ]
      },
      "Clube VIP VOJ8": {
        questions: [
          { question: "¿Cuántos niveles VIP existen en el Club VIP VOJ8?", answer: "50" },
          { question: "¿Cuánto tiempo tienes para reclamar el bono de nivel?", answer: "5 días" }
        ],
        fillInTheBlanks: [
          { text: "El Club VIP tiene __ niveles.", answer: "50" }
        ],
        flashcards: [
          { front: "Niveles VIP", back: "50" },
          { front: "Tiempo para reclamar bono", back: "5 días" }
        ]
      },
      "Super Programa de Indicação": {
        questions: [
          { question: "¿Cuál es el depósito mínimo que debe hacer un referido para que recibas bono?", answer: "R$20" },
          { question: "¿Cuánto recibes por cada referido que deposite R$20?", answer: "R$10" },
          { question: "¿Cuál es el rollover para el bono directo?", answer: "4x" },
          { question: "¿Hasta qué nivel de tu red recibes comisiones?", answer: "Hasta el segundo nivel" },
          { question: "¿Cuál es la comisión sobre 'Slots & Pesca' de tus indicados de Nivel 1?", answer: "0.50%" },
          { question: "¿Cuál es la comisión por depósito de tus referidos directos?", answer: "0.2%" },
          { question: "¿Cuál es el rollover para la comisión por depósito?", answer: "1x" }
        ],
        fillInTheBlanks: [
          { text: "El bono directo por referido es de R$__.", answer: "10" },
          { text: "El rollover para el bono directo es de __x.", answer: "4" },
          { text: "La comisión por depósito es de __%.", answer: "0.2" },
          { text: "El rollover para la comisión por depósito es de __x.", answer: "1" }
        ],
        flashcards: [
          { front: "Depósito mínimo referido", back: "R$20" },
          { front: "Bono directo", back: "R$10" },
          { front: "Rollover bono directo", back: "4x" },
          { front: "Comisión por depósito", back: "0,2%" },
          { front: "Rollover comisión depósito", back: "1x" },
          { front: "Niveles de comisión", back: "Hasta el segundo nivel" },
          { front: "Comisión Nivel 1 Slots", back: "0,5%" }
        ]
      },
      "Evento: ¡Feliz Cumpleaños!": {
        questions: [
          { question: "¿Qué porcentaje de bono se ofrece por el cumpleaños?", answer: "100%" },
          { question: "¿Cuál es el valor máximo del Cupón VIP de cumpleaños?", answer: "R$888" },
          { question: "¿Cuál es el rollover para el bono de cumpleaños?", answer: "10x" }
        ],
        fillInTheBlanks: [
          { text: "El bono de cumpleaños es de __% del depósito.", answer: "100" },
          { text: "El rollover para este bono es de __x.", answer: "10" }
        ],
        flashcards: [
          { front: "Porcentaje de bono cumpleaños", back: "100%" },
          { front: "Cupón VIP máximo", back: "R$888" },
          { front: "Rollover", back: "10x" }
        ]
      },
      "Chuva de Envelopes Premiados!": {
        questions: [
          { question: "¿Cuál es el depósito mínimo para participar?", answer: "R$20" },
          { question: "¿Cuántas veces al día se realizan los sorteos?", answer: "4" },
          { question: "¿Cuál es el premio máximo que se puede ganar?", answer: "R$8.888" }
        ],
        fillInTheBlanks: [
          { text: "El premio máximo en la Chuva de Envelopes es de R$__.", answer: "8888" }
        ],
        flashcards: [
          { front: "Depósito mínimo para participar", back: "R$20" },
          { front: "Número de sorteos diarios", back: "4" },
          { front: "Premio máximo", back: "R$8.888" }
        ]
      },
      "Código Premiado VOJ8": {
        questions: [
          { question: "¿Cuál es el depósito mínimo para participar?", answer: "R$20" },
          { question: "¿Cuál es el rollover si aciertas todos los números?", answer: "0x" },
          { question: "¿Qué se debe enviar para reclamar el premio?", answer: "El print de la apuesta" }
        ],
        fillInTheBlanks: [
          { text: "El rollover si aciertas todos los números es de __x.", answer: "0" }
        ],
        flashcards: [
          { front: "Depósito mínimo para participar", back: "R$20" },
          { front: "Rollover máximo", back: "0x" }
        ]
      },
      "Promoção da Sorte VOJ8: OVO PREMIADO 777": {
        questions: [
          { question: "¿Cuál es el rango del premio que se puede ganar?", answer: "R$7 a R$777" },
          { question: "¿Cuál es el depósito mínimo diario para participar?", answer: "R$20" },
          { question: "¿Qué acción se debe realizar para participar?", answer: "Enviar email a promosvoj8@gmail.com" },
          { question: "¿Cuál es el rollover para este bono?", answer: "1x" }
        ],
        fillInTheBlanks: [
          { text: "El rango del premio es de R$__ a R$777.", answer: "7" },
          { text: "El rollover para este bono es de __x.", answer: "1" }
        ],
        flashcards: [
          { front: "Rango del premio", back: "R$7 a R$777" },
          { front: "Depósito mínimo diario", back: "R$20" },
          { front: "Acción requerida", back: "Enviar email a promosvoj8@gmail.com" },
          { front: "Rollover", back: "1x" }
        ]
      },
      "Festival de Prêmios PG": {
        questions: [
          { question: "¿Cuál es el requisito de apuestas en slots de PG para participar?", answer: "R$1.000" },
          { question: "¿Cuántos ganadores diarios hay?", answer: "2000" },
          { question: "¿Cuál es el premio fijo por ganador?", answer: "R$50" },
          { question: "¿Cuál es el rollover para este bono?", answer: "1x" }
        ],
        fillInTheBlanks: [
          { text: "El requisito de apuesta diaria es de R$__ en slots PG.", answer: "1000" },
          { text: "El rollover para este bono es de __x.", answer: "1" }
        ],
        flashcards: [
          { front: "Requisito de apuesta diaria", back: "R$1.000" },
          { front: "Número de ganadores diarios", back: "2000" },
          { front: "Premio fijo por ganador", back: "R$50" },
          { front: "Rollover", back: "1x" }
        ]
      },
      "Bônus VOJ8 de Ganhos": {
        questions: [
          { question: "¿Cuál es el depósito mínimo para participar?", answer: "R$20" },
          { question: "¿Qué ganancia mínima se debe obtener en una apuesta para recibir el bono?", answer: "R$20" },
          { question: "¿Cuál es el monto del bono que se recibe?", answer: "R$10" },
          { question: "¿Cuál es el rollover para este bono?", answer: "1x" }
        ],
        fillInTheBlanks: [
          { text: "La ganancia mínima para recibir el bono es de R$__.", answer: "20" },
          { text: "El monto del bono es de R$__.", answer: "10" },
          { text: "El rollover para este bono es de __x.", answer: "1" }
        ],
        flashcards: [
          { front: "Depósito mínimo", back: "R$20" },
          { front: "Ganancia mínima", back: "R$20" },
          { front: "Monto del bono", back: "R$10" },
          { front: "Rollover", back: "1x" }
        ]
      },
      "Bônus Grátis: Ovo de Ouro da Sorte": {
        questions: [
          { question: "¿Qué dos acciones son necesarias para obtener el bono?", answer: "Vincular email y verificar teléfono" },
          { question: "¿Cuál es el premio máximo que se puede ganar?", answer: "R$1.088" }
        ],
        fillInTheBlanks: [
          { text: "El premio máximo del Ovo de Ouro es de R$__.", answer: "1088" }
        ],
        flashcards: [
          { front: "Acciones necesarias", back: "Vincular email y verificar teléfono" },
          { front: "Premio máximo", back: "R$1.088" }
        ]
      },
      "Momento de Compartilhar": {
        questions: [
          { question: "¿Cuánto se gana por compartir en Facebook?", answer: "R$5" },
          { question: "¿Cuánto se gana por compartir en Instagram?", answer: "R$5" },
          { question: "¿Cuánto tiempo debe permanecer visible la publicación?", answer: "12 horas" }
        ],
        fillInTheBlanks: [
          { text: "El tiempo mínimo de publicación es de __ horas.", answer: "12" }
        ],
        flashcards: [
          { front: "Premio por compartir en Facebook", back: "R$5" },
          { front: "Premio por compartir en Instagram", back: "R$5" },
          { front: "Tiempo mínimo de publicación", back: "12 horas" }
        ]
      }
    };

    const promotionDisplayNames = {
      "Bônus de 1º Depósito + Roda da Fortuna": "Bono 1er Depósito + Rueda",
      "Bônus de Segundo Depósito": "Bono de Segundo Depósito",
      "Bônus Diário de 10%": "Bono Diario del 10%",
      "Mega Check-in 10 Dias": "Mega Check-in de 10 Días",
      "Cashback Instantâneo": "Cashback Instantâneo",
      "Cashback Secreto": "Cashback Secreto",
      "Cashback USDT": "Cashback con Cripto",
      "Clube VIP VOJ8": "Club VIP",
      "Super Programa de Indicação": "Programa de Indicación",
      "Evento: ¡Feliz Cumpleaños!": "Bono de Cumpleaños",
      "Chuva de Envelopes Premiados!": "Lluvia de Sobres Premiados",
      "Código Premiado VOJ8": "Código Premiado",
      "Promoção da Sorte VOJ8: OVO PREMIADO 777": "Sorteo OVO PREMIADO 777",
      "Festival de Prêmios PG": "Festival de Premios PG",
      "Bônus VOJ8 de Ganhos": "Bono de Ganancias",
      "Bônus Grátis: Ovo de Ouro da Sorte": "Huevo de Oro de la Suerte",
      "Momento de Compartilhar": "Comparte y Gana"
    };

    /* =================== ESTADO =================== */
    let state = {
      currentView:'menu',
      activePromotionKey:null,
      activeGameLevel:0,
      progress:{},
      gameData:{},
      hardMode: false,
      timerId: null,
      deadline: null
    };
    const mainContent = document.getElementById('main-content');

    function initProgress(){
      try{ const saved=localStorage.getItem('voj8GameProgress'); state.progress=saved?JSON.parse(saved):{}; }catch{ state.progress={}; }
      getVisiblePromoKeys().forEach(k=>{ if(typeof state.progress[k]!=='number') state.progress[k]=0; });
      try{ state.hardMode = localStorage.getItem('voj8HardMode')==='1'; }catch{}
      saveProgress();
    }
    function saveProgress(){ try{ localStorage.setItem('voj8GameProgress', JSON.stringify(state.progress)); localStorage.setItem('voj8HardMode', state.hardMode?'1':'0'); }catch{} }

    /* =================== UI PRINCIPAL =================== */
    function getVisiblePromoKeys(){ return Object.keys(promotionDisplayNames).filter(k=>!!promotionsData[k]); }
    function render(){ mainContent.innerHTML=''; if(state.currentView==='menu') renderMenu(); else renderGame(); }

    function renderMenu(){
      const promoKeys = getVisiblePromoKeys();
      const maxLevel=5;

      const ruleBox = `
        <div class="card p-4 mb-6">
          <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
            <div>
              <h3 class="font-bold text-yellow-400 mb-1">Reglas</h3>
              <ul class="text-sm text-gray-300 list-disc pl-5 space-y-1">
                <li>Para desbloquear una ⭐ y el siguiente nivel debes responder <b>todas</b> las preguntas del juego <b>seguidas y sin errores</b>.</li>
                <li>Cada juego tiene un <b>temporizador</b>. Si se agota, se considera fallo y <b>no desbloqueas</b> el nivel.</li>
                <li>Las respuestas son coherentes entre juegos: si dos preguntas son la misma idea, la respuesta correcta es <b>exactamente la misma</b>.</li>
              </ul>
            </div>
            <label class="toggle text-sm"><input type="checkbox" id="hard-toggle" ${state.hardMode?'checked':''} onchange="toggleHardMode(this.checked)"><span>Modo Difícil</span></label>
          </div>
        </div>`;

      const cardsHTML = promoKeys.map(key=>{
        const displayName=promotionDisplayNames[key];
        const level=state.progress[key]||0;
        const stars='🌟'.repeat(level)+'☆'.repeat(maxLevel-level);
        return `
        <div class="card p-4 flex flex-col justify-between text-center fade-in hover:shadow-lg hover:border-yellow-400">
          <div>
            <h3 class="text-xl font-bold mb-2">${displayName}</h3>
            <p class="text-4xl mb-4">${stars}</p>
          </div>
          <button onclick="selectPromotion('${key}')" class="btn btn-gold py-2 px-4 mt-2">Entrenar</button>
        </div>`;
      }).join('');

      mainContent.innerHTML = `
        <section id="promotion-menu">
          <div class="flex justify-end mb-3">
            <button onclick="resetProgress()" class="btn bg-gray-700 text-white py-2 px-6 hover:bg-red-500">Reiniciar Historial</button>
          </div>
          ${ruleBox}
          <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">${cardsHTML}</div>
        </section>`;
    }
    function toggleHardMode(v){ state.hardMode=v; saveProgress(); }
    function resetProgress(){ getVisiblePromoKeys().forEach(k=>state.progress[k]=0); saveProgress(); render(); }

    function renderGame(){
      mainContent.innerHTML = '';
      const displayName = promotionDisplayNames[state.activePromotionKey] || state.activePromotionKey || '';
      const level=state.progress[state.activePromotionKey]||0;
      const gameTypes=['Opción Múltiple','Completar Texto (Selección Múltiple)','Completar la Regla','Verdadero/Falso','Tarjetas de Memoria'];
      const maxLevel=5;
      let list='';
      for(let i=1;i<=maxLevel;i++){
        const unlocked=i<=level+1, complete=i<=level;
        list+=`
          <button onclick="${unlocked?`startGame(${i})`:''}"
            class="btn p-4 w-full text-left ${unlocked?'bg-gray-700 hover:bg-yellow-400 hover:text-black scale-105':'bg-gray-800 text-gray-500 cursor-not-allowed'}">
            <div class="flex justify-between items-center">
              <span>Nivel ${i}: ${gameTypes[i-1]}</span>
              <span class="text-2xl">${complete?'✅':(unlocked?'▶️':'🔒')}</span>
            </div>
          </button>`;
      }
      const wrap=document.createElement('div');
      wrap.className='fade-in';
      wrap.innerHTML=`
        <div class="max-w-4xl mx-auto">
          <button onclick="goToMenu()" class="btn bg-gray-700 text-white py-2 px-4 mb-6 hover:bg-gray-600">← Volver al Menú</button>
          <div class="card p-6 md:p-8">
            <h2 class="text-3xl font-bold mb-3 text-center text-yellow-400">${displayName}</h2>
            <div id="timer-row" class="text-center mb-4 ${state.activeGameLevel? '':'hidden'}">
              <span class="text-sm text-gray-300">Tiempo restante:</span>
              <span id="timer-el" class="timer font-bold ml-2">--:--</span>
              ${state.hardMode?'<span class="ml-2 text-xs bg-yellow-500/20 text-yellow-400 px-2 py-1 rounded">Modo Difícil</span>':''}
            </div>
            <div id="game-content" class="space-y-4">${state.activeGameLevel===0?list:''}</div>
          </div>
        </div>`;
      mainContent.appendChild(wrap);

      if(state.activeGameLevel>0){
        const c=document.getElementById('game-content');
        setupTimerForLevel(); // tiempo NO tocado
        if(state.activeGameLevel===1) renderMultipleChoice(c);
        if(state.activeGameLevel===2) renderCompleteTextMC(c);
        if(state.activeGameLevel===3) renderFillInTheBlank(c);
        if(state.activeGameLevel===4) renderTrueFalse(c);
        if(state.activeGameLevel===5) renderFlashcards(c);
      }else{
        clearTimer();
      }
    }

    /* =================== TEMPORIZADOR (igual) =================== */
    function secsPerItemFor(level){
      const base = state.hardMode ? {1:18,2:16,3:14,4:10,5:10} : {1:24,2:22,3:20,4:14,5:12};
      return base[level] || 18;
    }
    function setupTimerForLevel(){
      clearTimer();
      const promo = promotionsData[state.activePromotionKey] || {};
      const level=state.activeGameLevel;
      let items=0;
      if(level===1) items = (promo.questions||[]).length;
      if(level===2){ const q=(promo.questions||[]).length, f=(promo.flashcards||[]).length, b=(promo.fillInTheBlanks||[]).length; items=q+f+b; }
      if(level===3) items = (promo.fillInTheBlanks||[]).length || 3;
      if(level===4) items = (promo.questions||[]).length || 4;
      if(level===5) items = (promo.flashcards||[]).length || 4;
      items = Math.max(items, 3);
      const totalSecs = Math.max(45, secsPerItemFor(level)*items);
      state.deadline = Date.now() + totalSecs*1000;
      state.timerId = setInterval(updateTimerUI, 200);
      updateTimerUI();
      document.getElementById('timer-row')?.classList.remove('hidden');
    }
    function clearTimer(){ if(state.timerId){ clearInterval(state.timerId); state.timerId=null; } state.deadline=null; }
    function updateTimerUI(){
      const el=document.getElementById('timer-el');
      if(!el || !state.deadline) return;
      const ms = state.deadline - Date.now();
      if(ms<=0){ el.textContent='00:00'; clearTimer();
        state.gameData.mistake = true;
        showSummary(document.getElementById('game-content'), true);
        return;
      }
      const s = Math.ceil(ms/1000); const m=Math.floor(s/60), ss=String(s%60).padStart(2,'0');
      el.textContent = `${m}:${ss}`;
      if(s<=10) el.classList.add('text-red-400'); else el.classList.remove('text-red-400');
    }

    /* =================== NORMALIZACIÓN =================== */
    const percentRe  = /^\d+([.,]\d+)?%$/i;
    const rolloverRe = /^\d+\s*x$/i;
    const moneyRe    = /^r\$/i;

    function canon(raw){
      let s = String(raw ?? '').trim().toLowerCase();

      // quitar acentos y limpiar
      s = s.normalize('NFD').replace(/\p{Diacritic}/gu,'');
      s = s.replace(/[^\w%$x\s\.,@-]/g,'').replace(/\s+/g,' ').trim();

      // formatos
      if (/%$/.test(s)) s = s.replace(',', '.');   // 0,3% -> 0.3%
      s = s.replace(/\be-mail\b/g,'email');        // e-mail -> email
      s = s.replace(/\bsin limite\b/g,'no hay limite');

      // ======= SINÓNIMOS CRÍTICOS =======
      // Todas las variantes del “perder todos los bonos / evento se reinicia”
      if (/(pierdes?|se pierden)\s+todos\s+los\s+bonos/.test(s)) s = 'pierdes todos los bonos';
      if (/(el\s+)?evento\s+se\s+reinicia.*(bono|bonos)/.test(s)) s = 'pierdes todos los bonos';
      if (/(faltar|omitir|omites?).*dia.*(bono|bonos)/.test(s)) s = 'pierdes todos los bonos';

      // otros mapeos canónicos
      if (/^un?\s*giro.*(roda|rueda).*fortuna/.test(s)) s = 'giro en la roda da fortuna';
      if (/^miembro.*telegram/.test(s)) s = 'ser miembro del grupo oficial de telegram';
      if (/^manual\s+al\s+depositar/.test(s)) s = 'manual al depositar';

      // numéricos
      if(percentRe.test(s)) return parseFloat(s);
      if(rolloverRe.test(s)) return parseFloat(s);
      if(moneyRe.test(s))   return parseFloat(s.replace(/[^\d]/g,''));
      if(/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);

      // limpieza final
      s = s.replace(/[^\w%$x\s\.,@]/g,'').trim();
      return s;
    }

    const fmtMoney = (n)=>`R$${Number(n).toLocaleString('pt-BR')}`;
    const uniqByCanon = (arr)=>{ const seen=new Set(); const out=[]; for(const v of arr){ const k=canon(v); if(!seen.has(k)){ seen.add(k); out.push(v); } } return out; };

    function getAllAnswersForPromo(promoKey){
      const data = promotionsData[promoKey]||{};
      const out = [];
      (data.questions||[]).forEach(q=>out.push(q.answer));
      (data.fillInTheBlanks||[]).forEach(q=>out.push(q.answer));
      (data.flashcards||[]).forEach(f=>out.push(f.back));
      return out;
    }

    /* =================== Distractores/Construcción =================== */
    function closeMoneyOptions(correctInt){
      const deltas = [Math.round(correctInt*0.05), 50, 100, 200].map(Math.abs);
      const cand = new Set();
      for(const d of deltas){ cand.add(correctInt+d); cand.add(Math.max(1, correctInt-d)); }
      return Array.from(cand).map(fmtMoney);
    }
    function closePercentOptions(p){
      const pool=[p-2,p-1,p+1,p+2,p+5,p-5].filter(x=>x>0).map(x=>`${x}%`);
      return uniqByCanon(pool);
    }
    function closeRolloverOptions(x){
      const pool=[x-2,x-1,x+1,x+2].filter(v=>v>0).map(v=>`${v}x`);
      return uniqByCanon(pool);
    }

    function contextCandidates(promoKey, qText, correct){
      const q=qText.toLowerCase();
      const c=canon(correct);

      if(typeof c==='number'){
        if(percentRe.test(correct)){
          return state.hardMode ? closePercentOptions(c) : ['5%','10%','15%','20%','25%','50%','100%'].filter(v=>canon(v)!==c);
        }
        if(rolloverRe.test(correct)){
          return state.hardMode ? closeRolloverOptions(c) : ['1x','3x','5x','10x','15x','20x','30x'].filter(v=>canon(v)!==c);
        }
        if(moneyRe.test(correct)){
          const near = state.hardMode ? closeMoneyOptions(c) : [500,1000,1500,2000,5555,8888].map(fmtMoney);
          return near.filter(v=>canon(v)!==c);
        }
      }

      const textCands = [];
      if(q.includes('premio adicional')) textCands.push('Cashback 5%','Puntos VIP','Cupón sorpresa');
      else if(q.includes('activa')||q.includes('accion')||q.includes('acción')) textCands.push('Automáticamente','Contactando soporte','Por Telegram');
      else if(q.includes('apuestas califican')) textCands.push('Solo slots','Solo apuestas deportivas','Solo poker');
      else if(q.includes('enviar')) textCands.push('El código','Un video','El ID de la apuesta');
      else if(q.includes('requisito principal')||q.includes('grupo')) textCands.push('Hacer una apuesta deportiva','Depositar con USDT','Ser VIP');

      if(state.hardMode && canon(correct)==='manual al depositar'){
        textCands.push('Automático al depositar','Manual después de depositar');
      }
      return uniqByCanon(textCands).filter(v=>canon(v)!==c);
    }

    function siblingTextDistractors(promoKey, correct){
      const pool = getAllAnswersForPromo(promoKey)
        .map(String)
        .filter(x=>canon(x)!==canon(correct) && !percentRe.test(x) && !rolloverRe.test(x) && !moneyRe.test(x));
      return uniqByCanon(pool).slice(0,3);
    }

    function ensureFour(opts, promoKey, qText, correct){
      let out = uniqByCanon(opts).filter(v=>canon(v)!==canon(correct));
      while(out.length<3){
        const sib = siblingTextDistractors(promoKey, correct).find(v=>!out.some(o=>canon(o)===canon(v)));
        if(sib) out.push(sib); else break;
      }
      const generic = ['Telegram','Depósito','Cashback','VIP','Premio','Apuesta','Rollover','Automático','Manual','Cupón'];
      let gi=0;
      while(out.length<3 && gi<generic.length){
        const g = generic[gi++]; 
        if(canon(g)!==canon(correct) && !out.some(o=>canon(o)===canon(g))) out.push(g);
      }
      out = uniqByCanon([correct, ...out]).slice(0,4);
      while(out.length<4) out.push('—');
      return shuffleArray(out);
    }

    function buildOptionsForQuestion(promoKey, qObj){
      const ctx = contextCandidates(promoKey, qObj.question, qObj.answer) || [];
      return ensureFour(ctx, promoKey, qObj.question, qObj.answer);
    }

    function buildOptionsForFill(text, answer, promoKey){
      const hasMoney   = /r\$\s*__/.test(text);
      const hasPercent = /__\s*%/.test(text);
      const hasRollover= /__\s*x/.test(text);
      let correctDisplay = answer;
      if(hasMoney   && /^\d+$/.test(answer)) correctDisplay = fmtMoney(answer);
      if(hasPercent && /^\d+([.,]\d+)?$/.test(answer)) correctDisplay = `${String(answer).replace(',', '.') }%`;
      if(hasRollover&& /^\d+$/.test(answer)) correctDisplay = `${answer}x`;
      const ctx = contextCandidates(promoKey, text, correctDisplay) || [];
      const options = ensureFour(ctx, promoKey, text, correctDisplay);
      return { options, correctDisplay };
    }

    /* =================== JUEGOS =================== */
    function startGame(level){
      state.activeGameLevel=level;
      state.gameData={
        review:[], mistake:false,
        currentQuestionIndex:0, completeIndex:0, fibIndex:0,
        currentTFIndex:0, currentTFShown:null,
        currentCardIndex:0, selfCheck:false, canNext:false
      };
      render();
    }

    function answersEqual(a,b){ try { return canon(a)===canon(b); } catch { return String(a).trim()===String(b).trim(); } }
    function stripIndexPrefix(s){ return String(s||'').replace(/^\s*\[\d\]\s*/,'').trim(); }

    /* ---- Nivel 1: Opción múltiple ---- */
    function renderMultipleChoice(container){
      const promo = promotionsData[state.activePromotionKey]||{};
      const questions = promo.questions||[];
      const { currentQuestionIndex=0 } = state.gameData;
      if(!questions.length){ showSummary(container); return; }
      if(currentQuestionIndex>=questions.length){ showSummary(container); return; }
      const q=questions[currentQuestionIndex];
      const options = buildOptionsForQuestion(state.activePromotionKey, q);
      container.innerHTML = `
        <p class="text-xl text-gray-300 mb-1">Pregunta ${currentQuestionIndex+1} de ${questions.length}</p>
        <h3 class="text-2xl font-semibold mb-4">${q.question}</h3>
        <div id="mc-grid" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-2">
          ${options.map((opt,i)=>`<button data-idx="${i+1}" onclick="checkMultipleChoiceAnswer(this,'${opt.replace(/\\/g,'\\\\').replace(/'/g,"\\'")}')" class="btn option-btn p-4 w-full text-left"><span class="mr-2 opacity-60">[${i+1}]</span>${opt}</button>`).join('')}
        </div>
        <div id="mc-explain" role="alert" class="text-sm text-gray-400"></div>`;

      const handler = (e)=>{
        if(['1','2','3','4'].includes(e.key)){
          const btn = document.querySelector(`#mc-grid .option-btn[data-idx="${e.key}"]`);
          if(btn && !btn.disabled) btn.click();
        }
      };
      window._mcHandler && document.removeEventListener('keydown', window._mcHandler);
      window._mcHandler = handler;
      document.addEventListener('keydown', handler);
    }
    function checkMultipleChoiceAnswer(button, selectedLiteral){
      const promo=promotionsData[state.activePromotionKey];
      const { currentQuestionIndex=0 } = state.gameData;
      const qObj = promo.questions[currentQuestionIndex];
      const correct = qObj.answer;

      const selectedFromBtn = stripIndexPrefix(button.innerText);
      const selected = selectedLiteral || selectedFromBtn;

      document.querySelectorAll('.option-btn').forEach(b=>{ b.disabled=true; b.setAttribute('aria-disabled','true'); });
      const explain = document.getElementById('mc-explain');

      const ok = answersEqual(selected, correct) || answersEqual(selectedFromBtn, correct);

      state.gameData.review.push({ q:qObj.question, correct, selected: selectedFromBtn, ok });

      if(ok){
        button.classList.add('correct'); if(SHOW_EXPLANATION && explain) explain.innerHTML = buildExplanation(qObj, correct);
        setTimeout(()=>{ state.gameData.currentQuestionIndex=currentQuestionIndex+1; renderMultipleChoice(document.getElementById('game-content')); },700);
      }else{
        state.gameData.mistake=true; button.classList.add('incorrect');
        document.querySelectorAll('.option-btn').forEach(b=>{ if(answersEqual(stripIndexPrefix(b.innerText), correct)) b.classList.add('correct'); });
        flashRedEffect(); if(explain) explain.innerHTML='';
        setTimeout(()=>{ state.gameData.currentQuestionIndex=0; renderMultipleChoice(document.getElementById('game-content')); },800);
      }
    }
    function buildExplanation(q, correct){
      const lc=q.question.toLowerCase();
      if(lc.includes('depósito mínimo')) return `📌 El mínimo es <b>${correct}</b>.`;
      if(lc.includes('porcentaje')) return `📌 El porcentaje oficial es <b>${correct}</b>.`;
      if(lc.includes('bono máximo')||lc.includes('premio máximo')) return `📌 El máximo permitido es <b>${correct}</b>.`;
      if(lc.includes('hora')) return `📌 El pago se programa a <b>${correct}</b>.`;
      if(lc.includes('rollover')) return `📌 El rollover definido es <b>${correct}</b>.`;
      if(lc.includes('acción')||lc.includes('activa')) return `📌 Se participa mediante <b>${correct}</b>.`;
      return `✅ Correcto: <b>${correct}</b>.`;
    }

    /* ---- Nivel 5: Flashcards (con bloqueo de “Siguiente”) ---- */
    function renderFlashcards(container){
      const promo = promotionsData[state.activePromotionKey]||{}; 
      const flashcards = promo.flashcards||[];
      const { currentCardIndex=0, selfCheck=false } = state.gameData;

      if(!flashcards.length){ showSummary(container); return; }
      if(currentCardIndex>=flashcards.length){ showSummary(container); return; }

      const card=flashcards[currentCardIndex];
      const hint = (promo.questions && promo.questions[currentCardIndex]) ? promo.questions[currentCardIndex].question : '';

      if (typeof state.gameData.canNext === 'undefined') state.gameData.canNext = false;

      container.innerHTML = `
        <p class="text-xl text-gray-300 mb-4">Tarjeta ${currentCardIndex+1} de ${flashcards.length}</p>
        ${hint?`<div class='mb-2 text-lg text-yellow-400 font-semibold'>Pista: ${hint}</div>`:''}
        <div class="flashcard-container h-64">
          <div id="flashcard" class="flashcard relative w-full h-full ${selfCheck?'is-flipped':''}">
            <div class="flashcard-face absolute w-full h-full card flex items-center justify-center p-4 text-center bg-gray-800 border-2 border-yellow-400">
              <h3 class="text-3xl font-bold">${card.front}</h3>
            </div>
            <div class="flashcard-back absolute w-full h-full card flex items-center justify-center p-4 text-center bg-yellow-400 text-black">
              <p class="text-2xl font-semibold">${card.back}</p>
            </div>
          </div>
        </div>
        <div class="mt-6 flex flex-col items-center gap-4">
          <div class="mt-2">
            <input type="text" id="flashcard-input" class="mx-2 p-2 rounded bg-gray-900 border-2 border-gray-600 focus:border-yellow-400 focus:outline-none text-center w-48" placeholder="Escribe la respuesta" />
            <button id="flash-check" onclick="checkFlashcardSelfCheck()" class="btn btn-gold py-2 px-4 ml-2">Comprobar</button>
          </div>
          <div class="flex gap-3">
            <button id="flash-reveal" onclick="flipCard()" class="btn bg-gray-600 py-3 px-6" disabled aria-disabled="true">Revelar</button>
            <button id="flash-next" onclick="nextFlashcard()" class="btn btn-gold py-3 px-6" disabled aria-disabled="true">Siguiente</button>
          </div>
          <div id="flashcard-feedback" role="alert" class="text-center text-xl font-bold mt-2 h-8"></div>
        </div>`;

      const input = document.getElementById('flashcard-input');
      const reveal = document.getElementById('flash-reveal');
      const toggleReveal = ()=>{
        const hasText = (input.value||'').trim().length>0;
        reveal.disabled = !hasText;
        reveal.setAttribute('aria-disabled', reveal.disabled?'true':'false');
      };
      input?.addEventListener('input', toggleReveal);
      input?.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          e.preventDefault();
          checkFlashcardSelfCheck();
        }
      });
      input?.focus();
      toggleReveal();
    }
    function flipCard(){ 
      const fc=document.getElementById('flashcard'); 
      if(fc){ fc.classList.toggle('is-flipped'); state.gameData.selfCheck=!state.gameData.selfCheck; } 
    }
    function checkFlashcardSelfCheck(){
      const promo=promotionsData[state.activePromotionKey]||{}; 
      const f=promo.flashcards||[]; 
      const { currentCardIndex=0 } = state.gameData;
      const input=document.getElementById('flashcard-input'); 
      const fb=document.getElementById('flashcard-feedback'); 
      const nextBtn=document.getElementById('flash-next');
      if(!input||!fb||!f[currentCardIndex]) return;

      const ok = answersEqual(input.value, f[currentCardIndex].back);
      fb.textContent = ok ? '¡Correcto!' : 'Sigue intentando';
      fb.style.color = ok ? 'var(--success)' : 'var(--error)';

      state.gameData.review.push({ q:`Flashcard: ${f[currentCardIndex].front}`, correct:f[currentCardIndex].back, selected:input.value, ok });

      if(ok){
        state.gameData.canNext = true;
        nextBtn?.removeAttribute('disabled');
        nextBtn?.setAttribute('aria-disabled','false');
      }else{
        state.gameData.mistake = true;
        state.gameData.canNext = false;
        nextBtn?.setAttribute('disabled','disabled');
        nextBtn?.setAttribute('aria-disabled','true');
      }
    }
    function nextFlashcard(){ 
      if(!state.gameData.canNext) return;
      const {currentCardIndex=0}=state.gameData; 
      state.gameData.currentCardIndex=currentCardIndex+1; 
      state.gameData.selfCheck=false; 
      state.gameData.canNext=false; 
      renderFlashcards(document.getElementById('game-content')); 
    }

    /* ---- Nivel 2: Completar texto (selección) ---- */
    function renderCompleteTextMC(container){
      const promo=promotionsData[state.activePromotionKey]||{};
      const { questions=[], flashcards=[], fillInTheBlanks=[] } = promo;
      let all=[];
      fillInTheBlanks.forEach(q=>all.push({text:q.text, answer:q.answer}));
      questions.forEach(q=>all.push({text:`La respuesta correcta a: '${q.question}' es __.`, answer:q.answer}));
      flashcards.forEach(f=>all.push({text:`La respuesta a la tarjeta: '${f.front}' es __.`, answer:f.back}));
      const { completeIndex=0 } = state.gameData;
      if(!all.length){ showSummary(container); return; }
      if(completeIndex>=all.length){ showSummary(container); return; }
      const item=all[completeIndex];
      const { options, correctDisplay } = buildOptionsForFill(item.text, item.answer, state.activePromotionKey);
      container.innerHTML = `
        <p class="text-xl text-gray-300 mb-4">Completa el texto seleccionando la opción correcta</p>
        <p class="text-2xl leading-relaxed text-center mb-6">${item.text.replace('__','<span class="underline text-yellow-400">____</span>')}</p>
        <div id="ct-grid" class="flex flex-col items-center gap-3 mb-2">
          ${options.map((opt,i)=>`<button data-idx="${i+1}" class="btn btn-gold py-2 px-6" onclick="checkCompleteTextMC(this,'${opt.replace(/\\/g,'\\\\').replace(/'/g,"\\'")}','${correctDisplay.replace(/\\/g,'\\\\').replace(/'/g,"\\'")}')"><span class="mr-2 opacity-60">[${i+1}]</span>${opt}</button>`).join('')}
        </div>
        <div id="complete-feedback" role="alert" class="text-center text-sm text-gray-400 h-6"></div>`;
      state.gameData.completeCurrentAnswer = correctDisplay;
      state.gameData.completeIndex = completeIndex;

      const handler = (e)=>{
        if(['1','2','3','4'].includes(e.key)){
          const btn = document.querySelector(`#ct-grid .btn[data-idx="${e.key}"]`);
          if(btn && !btn.disabled) btn.click();
        }
      };
      window._ctHandler && document.removeEventListener('keydown', window._ctHandler);
      window._ctHandler = handler;
      document.addEventListener('keydown', handler);
    }
    function checkCompleteTextMC(btn,selected,correctShown){
      const correct = state.gameData.completeCurrentAnswer || correctShown;
      const fb=document.getElementById('complete-feedback');
      document.querySelectorAll('#ct-grid .btn').forEach(b=>{ b.disabled=true; b.setAttribute('aria-disabled','true'); });
      const ok = answersEqual(selected, correct);
      const enunciado = document.querySelector('#game-content p.text-2xl')?.innerText || '';
      state.gameData.review.push({ q: enunciado.replace(/\s+/g,' ').trim(), correct, selected, ok });
      if(ok){
        if(SHOW_EXPLANATION) fb.innerHTML = `✅ Correcto: <b>${correct}</b>`;
        fb.style.color='var(--success)';
        setTimeout(()=>{ state.gameData.completeIndex=(state.gameData.completeIndex||0)+1; renderCompleteTextMC(document.getElementById('game-content')); },700);
      }else{
        state.gameData.mistake=true;
        fb.textContent='Incorrecto. Se reinicia el juego.'; fb.style.color='var(--error)'; flashRedEffect();
        setTimeout(()=>{ state.gameData.completeIndex=0; renderCompleteTextMC(document.getElementById('game-content')); },800);
      }
    }

    /* ---- Nivel 3: Completar con input ---- */
    function renderFillInTheBlank(container){
      const promo=promotionsData[state.activePromotionKey]||{}; const items=(promo.fillInTheBlanks||[]).slice();
      const { fibIndex=0 } = state.gameData;
      if(!items.length){ showSummary(container); return; }
      if(fibIndex>=items.length){ showSummary(container); return; }
      const cur=items[fibIndex];
      container.innerHTML = `
        <p class="text-xl text-gray-300 mb-4">Completa el espacio en blanco</p>
        <p class="text-2xl text-center mb-6">${cur.text.replace('__','<input id="fib-input" class="mx-2 p-2 rounded bg-gray-900 border-2 border-gray-600 focus:border-yellow-400 focus:outline-none text-center w-32" placeholder="...">')}</p>
        <div class="flex justify-center gap-4"><button id="fib-check" onclick="checkFIB()" class="btn btn-gold py-2 px-6">Comprobar</button></div>
        <div id="fib-feedback" role="alert" class="text-center text-sm text-gray-400 h-6"></div>`;
      state.gameData.fibAnswer=String(cur.answer);
      state.gameData.fibIndex=fibIndex;

      const fibInput = document.getElementById('fib-input');
      fibInput?.addEventListener('keydown',(e)=>{
        if(e.key==='Enter'){ e.preventDefault(); checkFIB(); }
      });
      fibInput?.focus();
    }
    function checkFIB(){
      const input=document.getElementById('fib-input'); const fb=document.getElementById('fib-feedback');
      const ok = answersEqual(input.value, String(state.gameData.fibAnswer||'')); 
      const enunciado = document.querySelector('#game-content p.text-2xl')?.innerText || '';
      state.gameData.review.push({ q: enunciado.replace(/\s+/g,' ').trim(), correct: state.gameData.fibAnswer, selected: input.value, ok });
      if(ok){ fb.textContent='¡Correcto!'; fb.style.color='var(--success)'; setTimeout(()=>{ state.gameData.fibIndex=(state.gameData.fibIndex||0)+1; renderFillInTheBlank(document.getElementById('game-content')); },700); }
      else{ state.gameData.mistake=true; fb.textContent='Incorrecto. Se reinicia el juego.'; fb.style.color='var(--error)'; flashRedEffect(); setTimeout(()=>{ state.gameData.fibIndex=0; renderFillInTheBlank(document.getElementById('game-content')); },800); }
    }

    /* ---- Nivel 4: Verdadero/Falso ---- */
    function renderTrueFalse(container){
      const promo=promotionsData[state.activePromotionKey]||{}; const questions=promo.questions||[];
      const { currentTFIndex=0 } = state.gameData;
      if(!questions.length){ showSummary(container); return; }
      if(currentTFIndex>=questions.length){ showSummary(container); return; }
      const q=questions[currentTFIndex];

      let ctx = contextCandidates(state.activePromotionKey, q.question, q.answer)||[];
      let wrong = ctx.find(o=>!answersEqual(o, q.answer));
      if(!wrong){
        const sibs = siblingTextDistractors(state.activePromotionKey, q.answer);
        wrong = sibs.find(o=>!answersEqual(o, q.answer));
      }
      if(!wrong){
        const fallbacks = ['Automático','Manual','Telegram','VIP','Cupón','Cashback 5%','Rollover 2x','R$50','10%'];
        wrong = fallbacks.find(o=>!answersEqual(o, q.answer)) || '—';
      }

      const showCorrect = (currentTFIndex % 2 === 0);
      const shown = showCorrect ? q.answer : wrong;
      state.gameData.currentTFShown = shown;

      container.innerHTML = `
        <p class="text-xl text-gray-300 mb-4">¿La siguiente afirmación es verdadera o falsa?</p>
        <div class="card p-6 mb-4 text-center text-2xl">${q.question} <br><span class='font-bold text-yellow-400'>${shown}</span></div>
        <div class="flex justify-center gap-4">
          <button id="tf-true"  onclick="checkTrueFalse(true,'${q.question.replace(/'/g,"\\'")}','${q.answer.replace(/'/g,"\\'")}')" class="btn btn-gold py-3 px-8">Verdadero</button>
          <button id="tf-false" onclick="checkTrueFalse(false,'${q.question.replace(/'/g,"\\'")}','${q.answer.replace(/'/g,"\\'")}')" class="btn bg-gray-600 py-3 px-8">Falso</button>
        </div>
        <div id="tf-feedback" role="alert" class="text-center text-sm text-gray-400 h-6"></div>`;

      const handler = (e)=>{
        if(e.key.toLowerCase()==='v'){ document.getElementById('tf-true')?.click(); }
        else if(e.key.toLowerCase()==='f'){ document.getElementById('tf-false')?.click(); }
        else if(e.key==='ArrowLeft'){ document.getElementById('tf-true')?.click(); }
        else if(e.key==='ArrowRight'){ document.getElementById('tf-false')?.click(); }
      };
      window._tfHandler && document.removeEventListener('keydown', window._tfHandler);
      window._tfHandler = handler;
      document.addEventListener('keydown', handler);
    }
    function checkTrueFalse(choice, qText, correct){
      const { currentTFIndex=0, currentTFShown } = state.gameData;
      const fb=document.getElementById('tf-feedback');
      document.getElementById('tf-true')?.setAttribute('disabled','disabled');
      document.getElementById('tf-true')?.setAttribute('aria-disabled','true');
      document.getElementById('tf-false')?.setAttribute('disabled','disabled');
      document.getElementById('tf-false')?.setAttribute('aria-disabled','true');

      const isTrue = answersEqual(currentTFShown, correct);
      const ok = choice===isTrue;
      state.gameData.review.push({ q:`${qText} → ${currentTFShown}`, correct, selected: choice?'Verdadero':'Falso', ok });
      if(ok){ fb.textContent='¡Correcto!'; fb.style.color='var(--success)'; setTimeout(()=>{ state.gameData.currentTFIndex=currentTFIndex+1; renderTrueFalse(document.getElementById('game-content')); },700); }
      else{ state.gameData.mistake=true; fb.textContent='Incorrecto. Se reinicia el juego.'; fb.style.color='var(--error)'; flashRedEffect(); setTimeout(()=>{ state.gameData.currentTFIndex=0; renderTrueFalse(document.getElementById('game-content')); },800); }
    }

    /* =================== RESUMEN =================== */
    function showSummary(container, fromTimeout=false){
      clearTimer();
      const review = state.gameData.review || [];
      const total = review.length;
      const aciertos = review.filter(r=>r.ok).length;
      const perfecto = !state.gameData.mistake && !fromTimeout && total>0 && aciertos===total;

      container.innerHTML = `
        <div class="card p-6 md:p-8">
          <h3 class="text-2xl font-bold mb-4 text-yellow-400 text-center">Resumen del juego</h3>
          <p class="text-center mb-2">Aciertos: <b>${aciertos}</b> / ${total} ${perfecto ? '✅ (Perfecto)' : (fromTimeout ? '⏰ Tiempo agotado' : '❌ Hubo errores')}</p>
          <div class="space-y-3 max-h-[60vh] overflow-auto pr-2">
            ${review.map((r,i)=>`
              <div class="p-3 rounded ${r.ok?'bg-green-900/30':'bg-red-900/25'}">
                <div class="text-sm text-gray-400 mb-1">#${i+1}</div>
                <div class="font-semibold mb-1">${r.q}</div>
                <div class="text-sm">Tu respuesta: <b>${r.selected || '—'}</b></div>
                <div class="text-sm">Correcta: <b>${r.correct}</b></div>
              </div>`).join('')}
          </div>
          <div class="text-center mt-6 flex justify-center gap-3">
            <button class="btn bg-gray-700 text-white py-2 px-6" onclick="retryGame()">Reintentar</button>
            <button class="btn btn-gold py-2 px-6" onclick="finishGame(${perfecto?'true':'false'})">${perfecto?'Terminar y desbloquear':'Terminar (sin desbloquear)'}</button>
          </div>
        </div>`;
    }
    function retryGame(){ startGame(state.activeGameLevel); }
    function finishGame(canUnlock){
      if(canUnlock){
        if(state.progress[state.activePromotionKey] < state.activeGameLevel){
          state.progress[state.activePromotionKey]=state.activeGameLevel;
          saveProgress();
        }
      }
      state.activeGameLevel=0; state.gameData={}; render();
    }

    /* =================== UTILS =================== */
    function shuffleArray(a){ const arr=[...a]; for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]]} return arr; }
    function flashRedEffect(){ const o=document.createElement('div'); Object.assign(o.style,{position:'fixed',top:0,left:0,width:'100vw',height:'100vh',background:'rgba(255,0,0,0.25)',zIndex:99999,pointerEvents:'none',transition:'opacity .5s'}); document.body.appendChild(o); setTimeout(()=>o.style.opacity='0',600); setTimeout(()=>o.remove(),900); }
    function goToMenu(){ clearTimer(); state.currentView='menu'; state.activePromotionKey=null; state.activeGameLevel=0; state.gameData={}; render(); }
    function clearAndRender(){ clearTimer(); render(); }
    function selectPromotion(key){ if(!promotionsData[key]){ alert('Promoción sin datos aún.'); return; } state.currentView='game'; state.activePromotionKey=key; state.activeGameLevel=0; state.gameData={}; clearAndRender(); }

    // limpiar hotkeys entre vistas
    function removeHotkeys(){
      window._mcHandler && document.removeEventListener('keydown', window._mcHandler);
      window._ctHandler && document.removeEventListener('keydown', window._ctHandler);
      window._tfHandler && document.removeEventListener('keydown', window._tfHandler);
      window._mcHandler = window._ctHandler = window._tfHandler = null;
    }
    const _origRender = render;
    render = function(){ removeHotkeys(); _origRender(); };

    document.addEventListener('DOMContentLoaded',()=>{ initProgress(); render(); });
  </script>
</body>
</html>
